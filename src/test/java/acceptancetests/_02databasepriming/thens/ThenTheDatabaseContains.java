package acceptancetests._02databasepriming.thens;

import acceptancetests._02databasepriming.givens.SpeciesInfoId;
import acceptancetests._02databasepriming.givens.SpeciesInfoRecord;
import com.googlecode.yatspec.state.givenwhenthen.TestState;
import org.jooq.DSLContext;
import org.jooq.Record5;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;

import javax.sql.DataSource;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.jooq.sources.Tables.SPECIFIESINFO;

// Creating a builder
public class ThenTheDatabaseContains {

  private SpeciesInfoId expectedSpeciesInfoId;
  private Integer expectedPersonId;
  private String expectedName;
  private Float expectedAverageHeight;
  // If we did not want to assert on a specific field/col in table/object,
  // we can use optional, and thus avoid having lots of build() methods for
  // all the permutations of fields to assert on
  private Optional<Integer> expectedLifespan = Optional.empty();

  private SpeciesInfoRecord expectedSpeciesInfo;

  private final TestState testState;
  private final DSLContext dslContext;

  public ThenTheDatabaseContains(TestState testState, DataSource dataSource) {
    this.testState = testState;
    this.dslContext = DSL.using(dataSource, SQLDialect.POSTGRES);
  }

  public ThenTheDatabaseContains forSpeciesInfoId(Integer expectedSpeciesInfoId) {
    this.expectedSpeciesInfoId = new SpeciesInfoId(expectedSpeciesInfoId);
    // As this generated, and cannot know the expected value, we can use interesting givens to
    //   capture the SpeciesInfoId to do this in the builder. where we can get the id (as it
    //   generated by then
    return this;
  }

  public ThenTheDatabaseContains forPersonId(Integer expectedPersonId) {
    this.expectedPersonId = expectedPersonId;
    return this;
  }

  public ThenTheDatabaseContains forName(String expectedName) {
    this.expectedName = expectedName;
    return this;
  }

  public ThenTheDatabaseContains forAverageHeight(Float expectedAverageHeight) {
    this.expectedAverageHeight = expectedAverageHeight;
    return this;
  }

  public ThenTheDatabaseContains forLifespan(Integer expectedLifespan) {
    this.expectedLifespan = Optional.of(expectedLifespan);
    return this;
  }

  // Instead of individual fields, can pass in the builder instead
  public ThenTheDatabaseContains withSpeciesInfo(SpeciesInfoRecord.SpeciesInfoRecordBuilder expectedSpeciesInfoBuilder) {
    // We can also add default build methods here, and let the test override them
    this.expectedSpeciesInfo = expectedSpeciesInfoBuilder.build();
    return this;
  }

  // Can create several of these, to improve naming (telescope pattern) and/or to assert on different things

  // This is the build method, where the assetions occur on each field
  public void wasSuccessfullyPersisted() {
    SpeciesInfoRecord actualSpeciesInfoRecord = readSpeciesInfoFromDatabase();
    assertThat(actualSpeciesInfoRecord.getSpeciesInfoId()).isEqualTo(expectedSpeciesInfoId); // This is redundant for this test, but for updates/insertions more useful
    assertThat(actualSpeciesInfoRecord.getPersonId()).isEqualTo(expectedPersonId);
    assertThat(actualSpeciesInfoRecord.getName()).isEqualTo(expectedName);
    assertThat(actualSpeciesInfoRecord.getAverageHeight()).isEqualTo(expectedAverageHeight);
    // Benefit of using optional allows for null check then does the assertion
    expectedLifespan.ifPresent(expectedLifespan -> assertThat(actualSpeciesInfoRecord.getLifespan()).isEqualTo(expectedLifespan));
  }

  // Using the expectedSpeciesInfo object to assert on instead of the individual fields
  public void wasInsertedIntoTheDatabase() {
    // Using this means that equals() needs to be overriden
    SpeciesInfoRecord actualSpeciesInfoRecord = readSpeciesInfoFromDatabase();
    assertThat(actualSpeciesInfoRecord).isEqualTo(expectedSpeciesInfo);
  }

  private SpeciesInfoRecord readSpeciesInfoFromDatabase() {
    Optional<Record5<Integer, Integer, String, Float, Integer>> result = dslContext.select(
        SPECIFIESINFO.SPECIES_ID,
        SPECIFIESINFO.PERSON_ID,
        SPECIFIESINFO.SPECIES,
        SPECIFIESINFO.AVG_HEIGHT,
        SPECIFIESINFO.LIFESPAN)
        .from(SPECIFIESINFO).fetchOptional();
    // Might want a different object, to include all the fields in the table
    SpeciesInfoRecord speciesInfoRecord = result.map(record -> new SpeciesInfoRecord(
        new SpeciesInfoId(record.component1()),
        record.component2(),
        record.component3(),
        record.component4(),
        record.component5())).orElseThrow(IllegalStateException::new);
    // To show in html, the database state after the when is called
    //   Not useful here as no update/deletion/insertion occurring, but for an example
    testState.log(String.format("Species Info after test execution for speciesInfo id '%s'", speciesInfoRecord.getSpeciesInfoId()), speciesInfoRecord);
    return speciesInfoRecord;
  }
}
